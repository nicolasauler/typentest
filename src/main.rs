use std::fs;

use reqwest::{self, header};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {

    let mut headers = header::HeaderMap::new();
    headers.insert("user-agent", "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/111.0".parse().unwrap());
    headers.insert("accept", "application/json, text/plain, */*".parse().unwrap());
    headers.insert("accept-language", "en-US,en;q=0.5".parse().unwrap());
    headers.insert("authorization", "Bearer token".parse().unwrap());
    headers.insert("content-type", "multipart/form-data; boundary=---------------------------304526952529175392321734552680".parse().unwrap());
    headers.insert("origin", "".parse().unwrap());
    headers.insert("dnt", "1".parse().unwrap());
    headers.insert("referer", "".parse().unwrap());
    headers.insert("sec-fetch-dest", "empty".parse().unwrap());
    headers.insert("sec-fetch-mode", "cors".parse().unwrap());
    headers.insert("sec-fetch-site", "same-origin".parse().unwrap());
    headers.insert("te", "trailers".parse().unwrap());

    let client = reqwest::Client::builder()
        .redirect(reqwest::redirect::Policy::none())
        .build()
        .unwrap();

    let content_types = fs::read_to_string("./content-types.txt")
        .unwrap()
        .lines()
        .map(|s| s.to_string())
        .collect::<Vec<String>>();

    for content_type in content_types {
        let req_body = format!("-----------------------------304526952529175392321734552680\r\nContent-Disposition: form-data; name=\"base64\"; filename=\"blob\"\r\nContent-Type: {}\r\n\r\n\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\r\n-----------------------------304526952529175392321734552680--", content_type);

        let res = client.post("")
            .headers(headers.clone())
            .body(req_body)
            .send().await?;

        println!("{:?}", res);
        let body = res.text().await?;
        println!("{:?}", body);

    }

    Ok(())
}
